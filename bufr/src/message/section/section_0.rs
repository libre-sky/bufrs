use std::u32;

use crate::message::{
    Message,
    section::{Section, error::InvalidSection},
};

/// ReadError is the enumeration of possible errors encountered in section parsing.

/// Section 0 is the first section of a BUFR message and has a fixed size of 8 bytes (octets).
/// ## Serialized layout
///
/// * 0-3: "BUFR"
/// * 4-6: message size, in bytes, read as a big-endian uint24 (max size 16,777,215)
/// * 7: BUFR edition
///
#[derive(Default, Debug)]
pub struct Section0 {
    pub msg_size: u32,
    pub version: u8,
}

impl Section0 {
    fn len() -> usize {
        8
    }

    fn validate_length(buf: &[u8]) -> Result<(), <Self as Section>::Error> {
        if Self::len() > buf.len() {
            Err(<Self as Section>::Error::InvalidLen(buf.len()))
        } else {
            Ok(())
        }
    }

    fn validate_protocol(buf: &[u8]) -> Result<(), <Self as Section>::Error> {
        if buf[..4] == b"BUFR"[..] {
            Ok(())
        } else {
            Err(<Self as Section>::Error::NotBufr(
                buf[..4].try_into().unwrap(),
            ))
        }
    }

    fn read_msg_size(buf: &[u8]) -> u32 {
        let data: [u8; 4] = [0, buf[4], buf[5], buf[6]];
        u32::from_be_bytes(data)
    }

    fn read_version(buf: &[u8]) -> u8 {
        buf[7]
    }
}

impl Section for Section0 {
    type Error = InvalidSection;
    fn len(&self) -> usize {
        Self::len()
    }

    fn read(buf: &[u8], _: &Message) -> Result<Self, Self::Error> {
        Self::validate_length(buf)?;
        Self::validate_protocol(buf)?;

        Ok(Self {
            msg_size: Self::read_msg_size(buf),
            version: Self::read_version(buf),
        })
    }
}

#[cfg(test)]
mod test {

    use crate::message::{
        Message,
        section::{Section, Section0},
    };

    const TEST_BUFR: [u8; 231] = [
        0x42, 0x55, 0x46, 0x52, 0x0, 0x0, 0xe7, 0x3, 0x0, 0x0, 0x16, 0x0, 0x0, 0x62, 0x0, 0x0, 0x1,
        0x6e, 0x18, 0x0, 0xc, 0xa, 0x1f, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9, 0x0,
        0x0, 0x1, 0x80, 0xc7, 0x50, 0x0, 0x0, 0xbc, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xf8, 0xf, 0xff, 0xff, 0xff, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x37, 0x37, 0x37,
        0x37,
    ];
    #[test]
    fn read_section() {
        let msg = Message::default();
        let res = <Section0 as Section>::read(&TEST_BUFR[..], &msg).unwrap();
        assert_eq!(res.msg_size, 231);
        assert_eq!(res.version, 3);
    }
}
